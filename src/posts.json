{
  "git-monorepo": {
    "title": "Git was not designed to support monorepos",
    "slug": "git-monorepo",
    "published": "2023-07-17",
    "body": "I work with monorepos in git on a daily basis and have learned through experience that git was not designed to support\nmonorepos. Can you build monorepos in git? Of course! There are some cases where I prefer a monorepo. However, there are\nspecific exit criteria that I use to determine when it is time to switch.\n\n\n### Why use a monorepo\n\nThere are a few reasons that I've heard on why some engineers choose to use a monorepo. Let's explore each of these \nreasons a bit before jumping into how `git` was not designed to support them.\n\n\n#### 1. Easier to add to an independent tool/service to existing repository\n\nIt is easier for an engineer to add a new tool or service to an existing repository where all of their tools have been\nalready been configured. Most repos have had configurations added to them to support linters, code formatters, editor\nconfigurations, and other miscellaneous configuration files for other tools that integrate with `git` repos. There is\nless friction creating a new directory in a repo that already has these configurations set up instead of copying and\npasting (**shudder**) them into a new repo, forgetting one, and having to go retrieve that one too.\n\n\n#### 2. Prevents repo sprawl\n\nAt a certain point, there is such a thing as too many repos. When \"Wait, which repo is that in again?\" or \"What was the\nname of that repo again?\" become a daily question, that is a signal that there are too many repos for the size of the\norganization--or maybe a symptom of having a bit too much creative liberty with the naming of repos. Either way, there\nis definitely something as having too many repos at the org level. \n\nThe last team that I was on had over a hundred different repos for the different puppet modules that we had. And we had\na primary repo that controlled which version of the puppet modules were being used in which infrastructure environment.\nI am not saying that this system was an incorrect setup. I am saying that it was a pain to have to remember which set of\nfive files was in each repo (Puppet modules have around ten files in them with the average lines of code being less than\na hundred). This seemed like too many active repos for a single team.\n\n\n#### 3. Makes it easier to share reusable code\n\nReusable code in the same repo is the easiest way to share code. I've done it myself when working on small personal\narduino projects. Any changes to the `/lib` directory automatically get picked up by the projects using it. However, it\nalso automatically breaks them when breaking changes are added to the `/lib` directory. It also couples the different\nprojects together to help communicate which versions of which work together. Barring any bugs, version 1.2.0 of App1 and\nApp2 will work together because they were developed and tested together.\n\n\n### Git was not designed for monorepos\n\nGit was and is not designed for monorepos. The Linux Kernel community developed `git` in response to losing the\nfree-of-charge status of the DVCS called BitKeeper [[1](https://git-scm.com/book/en/v2/Getting-Started-A-Short-History-of-Git)].\nThe Linux kernel is a single project and as such there were specific design decisions made that work really well with a\nsingle project repo, but does not work as well with a monorepo. The main decision that doesn't work well is git tags.\n\nA git commit is a reference to the state of the git tree at any one time. A git tag is an easier human readable\nreference to a commit. These references are helpful, even in some monorepos that have tightly coupled applications that\nrequire being coupled. However, as soon as they are treated as separate entities, tagging the entire repo together no\nlonger makes sense. If you can release version 1.3.1 of App1 and nothing has changed between version 1.3.1 and 1.3.0 of\nApp2, git tagging has broken. The main purpose of a version is to alert that there is a difference in the application.\nIf that communication tool is misused and the version fails to do its primary function, then there is no longer a purpose\nfor versioning those applications.\n\nTo overcome this issue, it has been proposed to use a monorepo naming standard like \"app1-1.3.1\" and \"app2-1.3.0\". This\ncan work to get around git not being designed to support monorepos. While it can work, I would mention that it feels bad\nto tag the entire tree of the monorepo to update a single project in the repo.\n\nThere are more technical issues in git for supporting monorepos that Atlassian goes into more depth in their article\n\"[Monorepos in git](https://www.atlassian.com/git/tutorials/monorepos)\".\n\n\n### Resulting Pain Points\n\nThere are some workarounds to get to a point where git can be adapted to host monorepos. However, those adaptions cause\nlater pain points. \n\n#### 1. Industry Standard CI/CD flows\n\nMonorepos primarily exist in two states, either tightly coupled applications sharing code or fully independent\napplications coupled through the repository. Low coupled applications have been found to be correlated with high rates\nof value delivery to end users.([Accelerate, Nichole Forsgren et al.](https://www.oreilly.com/library/view/accelerate/9781457191435/)). \nThe reverse correlation also stands: highly coupled applications are correlated with lower rates of value delivery to\nend users.\n\nThe technical solutions to help decouple applications and build in quicker feedback loops along the value stream assume\na single project to repo ratio. Multiple CI/CD flows are required to support a monorepo and more complex logic is needed\nto determine when to run those flows and when not to run others. In my experience, it takes a lot of effort to tweak the\nconfiguration to get it right, only to have the needs change for one/all of the projects later with some new dependency\nor shared library.\n\nIn addition to this, most monorepo structures are very custom to support the specific projects that they hold. Because\nof these snowflake designs, industry patterns using the available CI/CD tools may not work for the project. Every\nadventure into the CI/CD world of the monorepo becomes a balancing act because there are constraints between the\nprojects and the pipelines for those projects.\n\n\n#### 2. Automatic Dependency Management\n\nIt has become common practice to use an automated dependency manager to keep project dependencies up-to-date. GitHub's\nDependabot and Renovate are a couple of examples. As of today, neither of these leaders in dependency management support\nthe `<app>-<version>` standard of tagging of monorepos. If the software that is in the monorepo is used in other\nsoftware (library, sdk, GitHub Action, Dockerfile, Helm Chart), project specific tags cannot be used as a source. I\ndon't believe this will always be the case. Renovate currently has a [feature request open](https://github.com/renovatebot/renovate/issues/14546) \nto add such support. But that support is not yet available.\n\n\n### Key indicators to migrate\n\nEven with all of the above seeming to point away from monorepo use, I routinely create and use monorepos. I believe in\ndelivering value as fast as possible and also using the right tool for the job. That being said, I do have key\nindicators or exit criteria for when to look to migrate away from the monorepo.\n\n\n#### 1. Git Tagging and Release\n\nAs soon as I need to start tracking the version of a project with a git tag for internal or external release, it is time\nto make a dedicated project repository. The tagging becomes streamlined and the CI/CD becomes more manageable. But the\nbiggest value add is the long term maintainability. A simple structure with simplified CI/CD is a lot easier to manage\nlong term. It does not require almost-constant tweaking with the risk of breaking CI/CD pipelines for other projects.\n\n\n#### 2. Lines of Code\n\nWhen a single project in a monorepo gets large enough, it needs its own streamlined CI/CD. A lot of times this will go\nhand-in-hand with tagging and releasing (what project gets that large that isn't tagged and released?), but sometimes it\ndoesn't. When a project gets to about five thousand lines of code it is time to create a dedicated repository.\n\n\n### Migration\n\nTo migrate away from a monorepo, use the idea of [Evolutionary Architecture](https://evolutionaryarchitecture.com/) to \nfind the projects that can easily be removed from monorepo and moved out to its own. Then find the loosely coupled\napplications which are coupled, but not highly coupled and move them out to their own. Project by project, eventually\nthe repo structure will evolve from a monorepo to independent repos.\n\nTo help specifically with the use case where a monorepo was used to easily share code, move the shared code to a library \nproject and use [Minimum Viable CD](https://minimumcd.org/minimumcd/) to automatically release changes of the shared\ncode and \"publish\" it where the independent projects can get it. As soon as all tests pass, the change is merged, and\nthe project has been built, it will be available for consumption which removes the need for sharing code between apps\nvia a monorepo.\n\nStay tuned for the next article where I go in depth of a full streamlined CI/CD flow example of separate projects\ndepending on a central library, all with their own repos.\n"
  },
  "scalable-dev-overview": {
    "title": "Scalable Development Processes - Overview",
    "slug": "scalable-dev-overview",
    "published": "2023-07-24",
    "body": "This is the first of a series of articles on a git provider based flow that scales well from a handful of developers to\nmany developers working in the same repository. It will focus on modern processes to maximize value delivered from the\nValue Stream. We'll be walking through an fully implementation of the flow that can be used as a guideline for new\nprojects or what to use as a goal for a process migration.\n\n\n## CD - Continuous Delivery vs Continuous Deployment\n\nCD is a very important part in delivering and sustaining value in today's technological organizations. There are many\norganization benefits. Some of the benefits are: increased product stability, increased velocity in value delivery which\nleads to more value delivered, and improved culture supported by company processes. There is a more in depth analysis of\nthe benefits in\n[Accelerate](https://www.amazon.com/Accelerate-Software-Performing-Technology-Organizations/dp/1942788339). It examines\nthe correlations of many different variables in a technological organization and comes up with the four core metrics to\noptimize for in the value stream. Those metrics are what have become to be known as the DevOps metrics: Lead time to\nchange, change failure rate, deployment frequency, mean time to recovery. For definitions around these,\n[Atlassian](https://www.atlassian.com/devops/frameworks/devops-metrics) has a good overview of these metrics.\n\nThis is all great, but which CD are we talking about? The different between continuous delivery and continuous\ndeployment is the number of manual steps in the pipeline from the time where a software engineer commits a change to the\ntrunk branch and when it appears in Production. Here, Production can be defined as the end state where value is handed\nover to the end user. When talking about Production in the tech sense, most people will automatically think of a hosted\napplication. But in the context of CD, Production might also take the form of a released library or SDK.\n\nIt seems that engineers are drawn to continuous deployment. It focuses on minimizing the length of the development\nfeedback loops. Implementing continuous deployment produces the shortest feedback loops that you can have in value\ndelivery in the software world. However, continuous deployment can be scary to non-technical executives. The journey\ntowards continuous deployment is almost guaranteed to bring a higher count of failures from changes. For example, if an\norganization deploys to Production once a month, three of those deployments might cause system failures giving a change\nrate failure of 25%. Let's assume that the organization is able to update processes to release once a week and maintains\nthe same 25% change rate failure. This means that the number of changes that led to a system failure has increased to \n13. Without digging into the data and what it means, this increase in count can be uncomfortable for executives.\n    Inserting a manual step right before a deployment/release to Production to keep the decision to release a human one.\n\nIn addition to the above, continuous delivery might also be the only option depending on the technology being created.\nFor example, any client application being uploaded to a store front probably has to go through some sort of approval\nprocess before going live. This normally takes a few days. Continuous deployment won't be helpful because dismissing the\ncurrent review and updating the release asset multiple times a day will result in an application rarely getting through\nthe review process before needing to be updated again. Or you will be constrained to how often you can merge an update,\nwhich defeats the point of CD because it prevents faster delivery to the end users.\n\nThis series will be focused on scoping to continuous delivery with a stub out for where continuous deployment would go.\nThis is mostly because of the case of most application hosting environments are going to be different and the\ntechnologies used to deploy will differ from one group to another. \n\n\n## Minimum CD\n\nWe will be walking through an implementation of [MinimumCD](https://minimumcd.org/minimumcd/). The MinimumCD website is\na great resource to what it takes to implement CD and an amazing reference. A key point of understanding that it touches\non that will be needed before we get started is [Trunk Based Development](https://trunkbaseddevelopment.com/) branching\nstrategy and the usage of a single project in the repo (see [Git was not designed for\nmonorepos](https://joseph.flinnlab.com/posts/git-monorepo) for more information)\n\n\n## Automatic Versioning\n\nVersioning is an important part of communicating with both end users and internal stakeholders about updates that are\nreleased or even pending. Having a set definition of how to talk about different capabilities or fixes is important. And\nI have seen this important communication tool detract and get in the way of implementing MinimumCD. We will be walking\nthrough a automatic versioning scheme that fits very well into the developer workflow and will free up any need to worry \nabout versioning release assets or deployments. \n\n\n--- \n\nI'm excited to walk through the simple and scalable solution with y'all in the next few weeks. It can be immediately\nexecuted upon to start increasing value delivered to end users. Stay tuned!\n"
  }
}