{
  "git-monorepo": {
    "title": "Git was not designed to support monorepos",
    "stub": "git-monorepo",
    "date": "2023-07-17",
    "body": "I work with monorepos in git on a daily basis and have learned through experience that git was not designed to support\nmonorepos. Can you build monorepos in git? Of course! There are some cases where I prefer a monorepo. However, there are\nspecific exit criteria that I use to determine when it is time to switch.\n\n\n### Why use a monorepo\n\nThere are a few reasons that I've heard on why some engineers choose to use a monorepo. Let's explore each of these \nreasons a bit before jumping into how `git` was not designed to support them.\n\n\n#### 1. Easier to add to an independent tool/service to existing repository\n\nIt is easier for an engineer to add a new tool or service to an existing repository where all of their tools have been\nalready been configured. Most repos have had configurations added to them to support linters, code formatters, editor\nconfigurations, and other miscellaneous configuration files for other tools that integrate with `git` resdpos. There is\nless friction creating a new directory in a repo that already has these configurations set up instead of copying and\npasting (**shudder**) them into a new repo, forgetting one, and having to go retrieve that one too.\n\n\n#### 2. Prevents repo sprawl\n\nAt a certain point, there is such a thing as too many repos. When \"Wait, which repo is that in again?\" or \"What was the\nname of that repo again?\" become a daily question, that is a signal that there are too many repos for the size of the\norganization--or maybe a symptom of having a bit too much creative liberty with the naming of repos. Either way, there\nis definitely something as having too many repos at the org level. \n\nThe last team that I was on had over a hundred different repos for the different puppet modules that we had. And we had\na primary repo that controlled which version of the puppet modules were being used in which infrastructure environment.\nI am not saying that this system was an incorrect setup. I am saying that it was a pain to have to remember which set of\nfive files was in each repo (Puppet modules have around ten files in them with the average lines of code being less than\na hundred). This seemed like too many active repos for a single team.\n\n\n#### 3. Makes it easier to share reusable code\n\nReusable code in the same repo is the easiest way to share code. I've done it myself when working on small personal\narduino projects. Any changes to the `/lib` directory automatically get picked up by the projects using it. However, it\nalso automatically breaks them when breaking changes are added to the `/lib` directory. It also couples the different\nprojects together to help communicate which versions of which work together. Barring any bugs, version 1.2.0 of App1 and\nApp2 will work together because they were developed and tested toegether.\n\n\n### Git was not designed for monorepos\n\nGit was and is not designed for monorepos. The Linux Kernel community developed `git` in response to losing the\nfree-of-charge status of the DVCS called BitKeeper [[1](https://git-scm.com/book/en/v2/Getting-Started-A-Short-History-of-Git)].\nThe Linux kernel is a single project and as such there were specific design decisions made that work really well with a\nsingle project repo, but does not work as well with a monorepo. The main decision that doesn't work well is git tags.\n\nA git commit is a reference to the state of the git tree at any one time. A git tag is an easier human readable\nreference to a commit. These references are helpful, even in some monorepos that have tightly coupled applications that\nrequire being coupled. However, as soon as they are treated as separate entities, tagging the entire repo together no\nlonger makes sense. If you can release version 1.3.1 of App1 and nothing has changed between version 1.3.1 and 1.3.0 of\nApp2, git tagging has broken. The main purpose of a version is to alert that there is a difference in the application.\nIf that communication tool is misused and the version fails to do its primary function, then there is no longer a purpose\nfor versioning those applications.\n\nTo overcome this issue, it has been proposed to use a monorepo naming standard like \"app1-1.3.1\" and \"app2-1.3.0\". This\ncan work to get around git not being designed to support monorepos. While it can work, I would mention that it feels bad\nto tag the entire tree of the monorepo to update a single project in the repo.\n\nThere are more techincal issues in git for supporting monorepos that Atlassian goes into more depth in their article\n\"[Monorepos in git](https://www.atlassian.com/git/tutorials/monorepos)\".\n\n\n### Resulting Pain Points\n\nThere are some work arounds to get to a point where git can be adapted to host monorepos. However, those adaptions cause\nlater pain points. \n\n#### 1. Industry Standard CI/CD flows\n\nMonorepos primarily exist in two states, either tightly coupled applications sharing code or fully independent\napplications coupled through the repository. Low coupled applications have been found to be correlated with high rates\nof value delivery to end users.([Accelerate, Nichole Forsgren et al.](https://www.oreilly.com/library/view/accelerate/9781457191435/)). \nThe reverse correlation also stands: highly coupled applications are correlated with lower rates of value delivery to\nend users.\n\nThe technical solutions to help decouple applications and build in quicker feedback loops along the value stream assume\na single project to repo ratio. Multiple CI/CD flows are required to support a monorepo and more complex logic is needed\nto determine when to run those flows and when not to run others. In my experience, it takes a lot of effort to tweak the\nconfiguration to get it right, only to have the needs change for one/all of the projects later with some new dependency\nor shared library.\n\nIn addition to this, most monorepo structures are very custom to support the specific projects that they hold. Because\nof these snowflake designs, industry patterns using the avaiable CI/CD tools may not work for the project. Every\nadventure into the CI/CD world of the monorepo becomes a balancing act because there are constraints between the\nprojects and the pipelines for those projects.\n\n\n#### 2. Automatic Dependency Management\n\nIt has become common practice to use an automated depedency manager to keep project dependencies up-to-date. GitHub's\nDependabot and Renovate are a couple of examples. As of today, neither of these leaders in dependency management support\nthe `<app>-<version>` standard of tagging of monorepos. If the software that is in the monorepo is used in other\nsoftware (library, sdk, GitHub Action, Dockerfile, Helm Chart), project specific tags cannot be used as a source. I\ndon't believe this will always be the case. Renovate currently has a [feature request open](https://github.com/renovatebot/renovate/issues/14546) \nto add such support. But that support is not yet available.\n\n\n### Key indicators to migrate\n\nEven with all of the above seeming to point away from monorepo use, I routinely create and use monorepos. I believe in\ndelivering value as fast as possible and also using the right tool for the job. That being said, I do have key\nindicators or exit criteria for when to look to migrate away from the monorepo.\n\n\n#### 1. Git Tagging and Release\n\nAs soon as I need to start tracking the version of a project with a git tag for internal or external release, it is time\nto make a dedicated project repository. The tagging becomes streamlined and the CI/CD becomes more manageble. But the\nbiggest value add is the long term maintainability. A simple structure with simplified CI/CD is a lot easier to manage\nlong term. It does not require almost-constant tweaking with the risk of breaking CI/CD pipelines for other projects.\n\n\n#### 2. Lines of Code\n\nWhen a single project in a monorepo gets large enough, it needs its own streamlined CI/CD. A lot of times this will go\nhand-in-hand with tagging and releasing (what project gets that large that isn't tagged and released?), but sometimes it\ndoesn't. When a project gets to about five thousand lines of code it is time to create a dedicated repository.\n\n\n### Migration\n\nTo migrate away from a monorepo, use the idea of [Evoloutionary Architecture](https://evolutionaryarchitecture.com/) to \nfind the projects that can easily be removed from monorepo and moved out to its own. Then find the loosely coupled\napplications which are coupled, but not highly coupled and move them out to their own. Project by project, eventually\nthe repo structure will evolve from a monorepo to independent repos.\n\nTo help specifically with the use case where a monorepo was used to easily share code, move the shared code to a library \nproject and use [Minimum Viable CD](https://minimumcd.org/minimumcd/) to automatically release changes of the shared\ncode and \"publish\" it where the independent projects can get it. As soon as all tests pass, the change is merged, and\nthe project has been built, it will be available for consumption which removes the need for sharing code between apps\nvia a monorepo.\n\nStay tuned for the next article where I go in depth of a full streamlined CI/CD flow example of separate projects\ndepending on a central library, all with their own repos.\n\n\n\n\nAny view/opinions expressed in this article are mine alone and are not the views/opinions of my employer.\n"
  }
}